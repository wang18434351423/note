#### 什么是Redis

Redis是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列，分布式锁等场景。

Redis中提供了多种数据类型来支持不同的业务场景，String 字符串、Hash、List、Set、Sorted Set 有序集合、BItMaps 位图、GEO地理信息，并且对数据类型的操作都是原子性的，执行命令由单线程负责，不存在并发竞争。
此外，Redis还支持事务、持久化、lua脚本、多种集群方式（主从复制模式、哨兵模式、切片集群），发布\订阅模式，内存淘汰机制、过期删除机制。 

#### Redis中的主要模块

- 访问框架：网络访问框架、IO模型

- 操作模块：基于不同类型的 value 的各种操作

  > Redis 能够在实际业务场景中得到广泛的应用，得益于支持多样化类型的 value。

- 索引模块：redis 采用哈希表做为索引，能快速根据 key 找到对应的 value

- 存储模块：分配器、持久化（AOF、RDB）

- 高可用模块：主从复制、哨兵

- 高扩展模块：数据分片

#### Redis数据类型和底层数据结构

redis的数据类型：String 字符串、List 列表、Hash 哈希、Set 集合、Sorted Set 有序集合

底层数据结构：简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组

- 压缩列表：实际上是一个数组。
  - 表头维护了三个字段 zlbytes(列表长度)、zltail(列表尾偏移量) 和 zllen(列表元素个数)；
  - 在表尾维护了一个 zlend 表示列表结束。
  - 定位第一个元素和最后一个元素，可以通过表头的三个字段长度之间定位，复杂度是O(1)。查找其他元素只能挨个查找，复杂度为 O(n)
- 跳表：跳表在链表的基础上增加了多级索引，通过索引快速定位数据。
  - 跳表查找的时间复杂为 O(logN)
  - 跳表支持范围操作

> Redis 中尽量避免范围操作，以及集合的遍历操作，这类操作复杂度一般为 O(N)，比较耗时。可以使用 SCAN，渐进式遍历，每次返回有限的数据，避免一次性返回所有导致 Redis 阻塞。

#### 全局哈希表

Redis 使用一个哈希表来保存所有的键值对，其实就是一个大数组，数组中的每个元素称为一个哈希桶。

**链式哈希**：redis 解决哈希冲突的方式，同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。

#### Redis 的 rehash

为了让 rehash 更加高效，redis 使用了两张全局哈希表。当哈希表1的数据越来越多，redis开始rehash：

- 给哈希表2分配更大的空间，例如是哈希表1的二倍
- 将哈希表1中的数据重新映射并拷贝到哈希表2中
- 释放哈希表1的空间

如果一次性将哈希表1中的数据都迁移完，会造成 Redis 的线程阻塞，无法服务其他请求。为了避免这个问题，redis 采用了渐进式 rehash

**渐进式 rehash**：redis 正常处理客户端请求，每处理一个请求，从哈希表1中取一个哈希桶上的元素拷贝到哈希表2中。这样将一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作。

**rehash的时机**：Redis 会使用装载因子来判断是否需要 rehash。装载因子的计算方式为，哈希表中所有 entry 的个数除以哈希表的哈希桶个数。

- 1 <= 装载因子 < 5 ，哈希表被允许进行 rehash，但此时要看是否在进行 RDB 生成或 AOF 重写，这是为了避免对 RDB 和 AOF 重写造成影响，这两项都没有进行，就可以开始 rehash 了。
- 装载因子 >= 5，哈希表中此时有大量的链式哈希存在，立刻开始 rehash。

**定时任务 rehash**：采用渐进式 rehash，如果实例暂时没有收到新请求，Redis 也会定时执行一次 rehash 操作，但每次执行时间不会超过 1ms，以免对其他任务造成影响。

#### **Redis的单线程**

Redis 是单线程，主要指的是 Redis 的网络 IO 和键值对读写是由一个线程完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，持久化、异步删除、集群数据同步等都是由额外的线程执行的。

为什么使用单线程：多线程编程模式面临共享资源的并发访问控制，并发访问控制如果没有精细的设计很难达到理想效果。

**linux的IO多路复用机制**：IO 多路复用就是通过一个进程可以监视多个描述符，一旦某个描述符就绪，能够同时往程序进行相应的读写操作的一种机制。优点是系统开销小，不必创建线程或进程。该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求，一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。这样，Redis 线程就不会阻塞在某一个特定的客户端请求上，从而提升并发性。

epoll 机制提供了基于事件的回调，针对不同的事件，调用相应的处理函数。一旦检测到有请求到达，就会触发相应的事件，这些事件将放入一个事件队列，Redis 单线程对该事件队列不断进行处理，这样 Redis 无需轮询是否有请求发生，避免 CPU 资源浪费，Redis 在处理事件时，会调用相应的处理函数，实现基于事件的回调。

> select、poll、epoll，都是用于在 IO 多路复用中的系统调用，用于监听多个文件描述符的可读、可写或异常事件。
>
> select
>
> - select 是最古老的 IO 多路复用机制之一，通过 fd_set 数组保存文件描述符的状态，通过 select 系统调用阻塞等待某个文件描述符就绪。
>- 优点：可移植性好，几乎所有的操作系统都支持。
> - 缺点：效率低，文件描述符数量较大时，性能下降明显，fd_set 数组大小受限，通常只能处理少量的文件描述符。每次操作，都需要拷贝 fd_set。
>
> poll
>
> - poll 与 select 原理相似，都需要来回拷贝全部监听的文件描述符。
>- 优点：采用链表保存文件描述符，没有数量限制，移植性好。
> - 缺点：采用线性的扫描方式，在文件描述符数量较大时性能差。
>
> epoll
>
> - epoll 是 linux 特有的 IO 多路复用机制，它通过内核支持的红黑树或双向链表来保存文件描述符的状态，使用了三个系统调用 epoll_create、epoll_ctl、epoll_wait。
>- 优点：高性能、支持较大的并发连接数，通过事件驱动的方式，只返回发生事件的文件描述符，避免了线性扫描。利用 mmap 将用户空间的一块地址和内核空间的一块地址映射到相同的一块物理地址，减少了用户态和核心态之间的数据交换，加速了与内核空间的消息传递，减少了复制开销。
> - 缺点：只能在 linux 系统上使用。

#### AOF 日志

Redis 实现数据的持久化，避免从后端数据库进行恢复是必要的，避免给数据库造成压力，避免影响服务的响应速度。

AOF 中记录的是 Redis 收到的每一条命令，这些命令以文本形式保存。AOF 日志是在主线程中执行的。

AOF是**写后日志**，redis 先执行命令，再记录日志。优势是在数据恢复时，不需要校验命令的合法性，避免检查开销；另一个优势是，在命令执行之后记录，不会阻塞当前的写操作。

##### 三种回写策略

AOF 日志写回磁盘的时机有三个选项，可通过 AOF 配置项 appendfsync 进行配置

- Always，同步写回，每个写命令执行完，立马同步的将日志写回磁盘。可以基本做到不丢数据，但每一个写命令后都有一个落盘动作，影响主线程性能
- Everysec，每秒写回，每个写命令执行完，先把日志写到 AOF 文件的内存缓冲区，每隔一秒将缓冲区的内容写回磁盘，性能适中，如果宕机，会丢失一秒的数据
- No，由操作系统控制写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘，性能最好，但落盘时机不在 Redis 手中，如果宕机，对应的数据就会丢失

##### AOF 重写

原因：随着命令越来越多，AOF 文件的体积会越来越大。

- 文件系统本身对文件大小有限制
- 文件过大，追加命令记录效率也会变低
- 文件过大，故障后恢复过程缓慢

AOF 重写取的是键值对的最新状态，为它生成对应的写入命令。如果这个键值之前被操作过很多次，那么旧文件中记录的多条命令，在新 AOF 文件中只需要一条命令表示，这样能节省很多空间。

重写操作：

- 内存拷贝：主线程 fork 出后台的 bgrewriteaof 子进程，并将内存拷贝给子进程。主线程的内存中包含了数据库最新数据，子进程就可以逐一将数据写入新日志。
- 两处日志：重写过程中接收到新操作，会同时同步到新、旧 AOF 日志的缓冲区中。
  - 新 AOF 在重写的同时也能接受到最新操作，这样重写完成之后就可以替换旧文件了。
  - 旧 AOF 日志正常工作是防止万一重写过程中宕机，仍可以用旧日志恢复数据。

##### AOF的写缓冲区

AOF（Append-Only File）持久化机制中的写缓冲区是指一块内存区域，用于缓存数据库写操作（如SET、INCR等）生成的日志条目，然后将这些日志条目批量写入AOF日志文件，以提高性能。

写缓冲区在AOF机制中起到了重要的作用，它的主要功能包括：

1. **减少磁盘写入次数：** 通过将多个写操作的日志条目缓存在内存中，而不是每个写操作都立即写入AOF文件，可以降低磁盘写入的频率。这样可以提高性能，减少磁盘I/O的开销。
2. **合并多个写操作：** 写缓冲区可以合并多个连续的写操作，将它们合并成一个更大的写操作，从而减少AOF文件中的写入操作数量。这有助于减小AOF文件的大小，提高了AOF文件的可读性。
3. **提高数据写入效率：** 写缓冲区通常使用顺序写入，这在磁盘操作中效率更高。相比随机写入，顺序写入可以更好地利用磁盘的缓存和批量写入性能。

写缓冲区的大小通常是可以配置的，可以根据应用程序的需求和性能来调整。如果写缓冲区太小，可能会导致频繁的写入操作，降低性能。如果写缓冲区太大，可能会占用过多的内存。因此，需要在性能和内存占用之间进行权衡。

#### RDB 快照

Redis 的 RDB 快照做的是全量快照。

Redis 提供了两种命令来生成 RDB 文件：

- save：在主线程中执行，会导致阻塞
- bgsave：创建一个子进程，专门用于写入 RDB 文件，避免主线程的阻塞，这也是默认配置。

**写时复制**：Redis 在快照过程中，采用写时复制技术，正常处理写操作，如果主线程要修改数据，那么会生成这块数据的副本，然后 bgsave 子进程会把副本数据写入 RDB 文件，从而保证快照的完整性。

> 写时复制的底层实现机制：主线程在 fork 出 bgsave 子进程后，bgsave 子进程会复制主线程的页表，这些页表中保存了在执行 bgsave 命令时，主线程所有数据块在内存中的物理地址，这样 bgsave 就可以根据页表读取数据写入磁盘。如果此时主线程收到修改操作，会利用写时复制机制，将新写或修改后的数据写入到一个新的物理地址中，并修改自己的页表映射，相当于在页表中增加新物理页，而不是修改原数据所在的物理页。

##### 如何保证数据不丢

Redis 4.0 后，可以混合使用 AOF 日志和内存快照，在两次快照之间使用 AOF 日志记录命令。这样可以避免频繁快照，而且只记录两次快照之间的命令，AOF 文件不会过大，可以避免 AOF 重写的开销。

> 频繁快照的问题，频繁的全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，容易造成恶性循环。

#### Redis 的主从数据同步

Redis 的高可靠：一是数据尽量少丢失，二是服务尽量少中断。AOF 和 RDB 保证了前者，后者 Redis 的做法是增加副本冗余，将一份数据同时保存在多个实例上，即使一个实例出现故障，其他实例也可以对外提供服务。

Redis 提供了主从库模式，以保证数据副本的一致。主从库之间采用读写分离。

- 读操作：主库、从库都可以接收
- 写操作：首先到主库执行，然后主库将写操作同步给从库

> 如果从库也可以接收写操作，那么各个库之间的数据同步的开销会很大，涉及到加锁、协商等等。

Redis 提供了 replicaof 命令进行主库和从库的挂载

##### 主从库的数据同步

- 第一次数据同步，第一步，主从库之间建立连接，协商同步，从库给主库发送 psync 命令传递 主库的 runID 和复制进度 offset 参数，主库返回 FULLRESYNC 响应
- 第二步，主库执行 bgsave 命令生成 RDB 文件，将文件发送给从库。从库接受到文件后清空数据库，然后加载 RDB 文件。同步过程中，主库不会阻塞，可以正常接收请求，为保证主从库数据一致性，主库会用 replication buffer 记录 RDB 文件生成后收到的所有写操作。
- 第三步，当主库完成 RDB 文件的发送后，会将 replicaton buffer 中的修改操作发送给从库，这样主从库就实现同步了
- 主从库一旦完成全量同步，它们之间会一直维护一个网络连接，主库会通过这个链接将后续收到的命令同步给从库，这时进行的是增量同步，通过环形缓冲区进行，主库和从库会各自记录自己的复制进度。

##### 网络断联

Redis 2.8 之前，主从库在命令传播时，出现网络闪断，那么从库就会和主从重新进行一次全量复制，开销非常大。

Redis 2.8 之后，网络断了之后，出从之前采用增量复制的方式继续同步，只同步网络断联期主库收到的命令。

- 主从库断联后，主库会把断联期间收到的写操作命令，写入 replication buffer 和 repl_backlog_buffer 缓冲区
- repl_backlog_buffer 是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置。
- 主从恢复连接后，从库会将缓冲区读到位置发送给主库，主库将相差的增量部分同步给从库。
- 问题：如果环形缓冲区满了，主库会继续写入，这样会覆盖掉之前的写入操作。可以通过调大缓冲区大小（repl_backlog_size）尽量减少从库在网络断联时全量复制的风险。

##### raplication buffer 和 repl_backlog_buffer 的区别

raplication buffer ：是主从库在进行全量复制时，主库用于和从库链接的客户端 buffer，主库通过这个 buffer 将全量复制期间的写操作命令发送给从库。replication buffer 不是共享的，主库会给每个从库都建立一个客户端。

repl_backlog_buffer：是为了支持从库增量复制，主库上用于持续保存写操作的一块专用 buffer，是所有从库共享的。主库和从库会记录自己的复制进度，不同的从库在进行恢复时，会把自己的复制进度（slave_repl_offset）发送给主库，主库就可以和它独立同步。

##### 主从级联分摊全量复制时主库的压力

如果从库数量很多，而且都需要和主库进行全量复制，主库忙于 fork 子进程生成 RDB 文件，fork 操作会阻塞主线程，且 RDB 文件传输也会占用主库的网络带宽。

可以通过 ”主-从-从“ 的模式，将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。在搭建集群时，选择配置较高的从库，用于级联其他从库，作为其他从库的主库。

#### 哨兵机制

哨兵主要负责的三个任务：监控、选主（选择主库）和通知。

- 监控：哨兵会在运行过程中周期性的给所有主从库发送 PING 命令，检测它们是否在线运行，如果从库没有在规定时间内响应，哨兵会将其标记为 "下线状态"；如果主库没有在规定时间内响应，哨兵判定主库下线，开始自动切换主库流程
  - 哨兵进程会使用 PING 命令，检测它和主、从库的网络连接状况，来判断实例的状态
  - 从库下线一般影响不大。但主库下线不能立刻开启主从切换，要防止误判，避免不必要的开销。哨兵通常采用多实例、集群部署，多个哨兵实例一起判断，避免误判。
  - 主库下线分为客观下线，主观下线。单个哨兵实例判定主库下线为主观下线，客观下线的标准为半数以上的哨兵实例判断主库为主观下线，这个客观下线的实例数量可以自行控制。主库客观下线，才能开启主从切换。
- 选主：主库挂了之后，哨兵需要从从库中按照一定的规则选择一个新主库。
  - 1、检查从库当前的在线状态，判断从库之前的网络连接状况。筛选掉不在线的从库，以及网络状况不好，之前和主库断联超过设定阈值的从库。
  - 2、优先级最高的从库得分最高，从库的优先级可以手动指定。（比如提前将配置较高的从库指定高优先级）
  - 3、和旧主库同步程度最接近的从库得分高，查看从库中环形缓冲区读位置，和主库的写位置进行计算，最接近的得分高。
  - 4、ID号小的得分高，在优先级和复制进度相同的情况下。
- 通知：新主库切换完成后，哨兵会将新主库的连接信息发送给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。

#### 哨兵集群

多个哨兵实例组成哨兵集群，即使有实例挂掉了，其他哨兵可以继续协作完成主从库的切换工作。

##### 基于 pub/sub 机制的哨兵集群组成

部署哨兵集群时，只需要需要配置主库的 ip 和端口，并不需要配置其他哨兵的连接信息。

哨兵之间互相发现，基于 Redis 提供的 pub/sub 机制，也就是发布/订阅机制。哨兵和主库建立连接之后就可以在主库上的哨兵频道（sentinel:hello 频道）发布消息和订阅消息，当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口号了。接着，哨兵通过向主库发送 INFO 命令，获取所有的从库信息，和每个从库建立连接，并在连接上持续对从库进行监控。

> 为区分不同应用的消息，Redis 会以频道的形式，对这些消息进行分门别类的管理。频道就是消息的类别，只有订阅了同一个频道的应用，才能通过发布的消息进行信息交换。

##### 基于 pub/sub 机制的客户端通知

哨兵是一个运行在特定模式下的 Redis 实例，每个哨兵也提供 pub/sub 机制。客户端可以从哨兵订阅消息。哨兵提供了很多订阅频道，包含主从库切换过程中的不同关键事件（主库下线、从库重新配置、新主库切换等）。

有了这些事件通知，客户端就可以在主从切换之后获取到新主库的连接信息，以及监控主从切换的进度。

##### leader 选择机制

主从切换中，需要确定由哪个哨兵作为 leader 执行具体步骤。

在哨兵集群中，主库客观下线的票数是通过哨兵配置文件中的 quorum 配置项设定的，任何一个实例判断主库主观下线，就会给其他实例发送命令获取投票信息，其他实例会根据自己和主库的连接情况作出响应。

主库客观下线后，进行 leader 选举。称为 leader 有两个条件：

- 拿到半数以上的赞成票
- 拿到的票数大于哨兵配置文件中的 quorum 值

#### 切片集群

切片集群，也叫分片集群，指启动多个 Redis 实例组成一个集群，按照一定的规则把数据分为多份，每一份用一个实例保存。

##### redis扩展

纵向扩展：升级单个 Reids 实例的资源配置，增加内存容量、磁盘容量等

- 优点：实施起来简单、直接
- 问题：RDB 持久化时，redis 内存大，主线程在 fork 子进程时可能会阻塞。（如果不要求持久化保存，纵向扩展是一个不错的选择。）纵向扩展还会受到硬件和成本的限制。

横向扩展：增加 Redis 实例个数

- 优点：扩展性更好，单个实例中数据量不会过大，不用担心单个实例的硬件和成本限制，在面对巨大的用户规模时，是一个好的选择。

reids 的持久化机制中，redis 会 fork 子进程进行 RDB 快照，fork 操作会阻塞主线程，且 Redis 的数据量越大 fork 需要的事件越长。因为创建子进程时，内核要将主线程的PCB（进程控制块） 内容拷贝给子进程，过程中要把主线程的页表拷贝到子进程中，Redis 内存越大，页表越大，拷贝时间越长，整个过程由内核执行是会阻塞主线程的。

- 如果在单台 redis 中保存过多数据，fork 子进程时会导致主线程阻塞，redis 响应变慢。

- 如果采用切片集群，将数据切片保存到多个实例中，每个实例中的数据量小，fork 操作不会给主线程带来较长时间的阻塞。

#### Redis Cluster

Redis 3.0 之后提供了针对切片集群的具体方案：Redis Cluster。

Redis Cluster 方案采用哈希槽（Hash Slot）来处理数据和实例之间的映射关系。在 Redis Cluster 中一共有 16384 个哈希槽，哈希槽相当于数据分区，每个键值对都会根据key，映射到一个哈希槽中。

> 映射步骤：根据键值对的 key，按照 CRC16 算法计算一个 16bit 的值，在用这个值对 16384 取模，获取到哈希槽编号。

哈希槽和 Redis 实例的映射

- 部署 Redis Cluster 时，使用 cluster create 命令创建集群，Redis 会自动平均分配
- 也可以使用 cluster meet 命令手动建立实例之间的连接，再使用 cluster addslots 指定每个实例的哈希槽数，但手动分配时，必须把 16384 个槽都分配完，否则集群将无法正常工作。

客户端定位数据：

- Redis 实例会互相通信，完成哈希槽分配信息的扩散，这样每个实例中就有所有的哈希槽映射关系了。
- 客户端和集群实例建立连接后，实例会将哈希槽映射关系发送给客户端，客户端收到后缓存在本地，在请求键值对时，先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。

客户端感知哈希槽变化：

- 集群中哈希槽和实例的对应关系并不是一成不变的，实例有新增或删除，或者为了负载均衡都会重新分配哈希槽，此时实例之间可以互相通信获取最新哈希槽分配信息。

- **重定向机制**

  客户端向一个实例发送请求，如果这个实例上没有这个键值对映射的哈希槽，那么会给客户端返回 MOVED 命令，其中包含新实例的访问地址，客户端和新实例地址连接并更新本地缓存的哈希槽分配信息，继续进行操作。特殊情况：哈希槽迁移部分完成的情况，哈希槽中只有一部分迁移到新实例了，这时客户端发来请求，会收到 ASK 命令，其中会携带新实例地址，此时客户端需要先给新实例发送 ASKING 命令，让新实例允许执行客户端接下来发送的命令，然后客户端继续发送 GET 命令。与 MOVED 命令不同，ASK 命令不会更新客户端缓存的哈希槽分配信息，ASK 命令的作用只是让客户端能给新实例发送一次请求。

#### Redis 中 fork 的子进程有哪些

- bgsave，创建 RDB 的后台子进程，同时由它负责在主从同步时传输 RDB 给从库
- 通过无盘复制方式传输 RDB 的子进程
- bgrewriteaof 子进程，负责 aof 文件的重写
- 后台线程，Redis 4.0 开始使用 pthread_create 创建后台线程，一般会执行一些任务，例如异步删除任务

#### Redis 的内存区域

1. **键空间：** Redis的主要数据存储区域，包括各种数据类型（字符串、列表、哈希、集合、有序集合等）的键值对。所有的数据都存储在这个区域中。
2. **过期键空间：** Redis中的键可以设置过期时间，过期键空间用于存储那些设置了过期时间的键。Redis会定期检查过期键空间，删除已过期的键。
3. **缓冲区：** Redis使用缓冲区来存储新写入的数据，然后批量写入到磁盘，以提高写入性能。这个缓冲区通常称为"写入缓冲区"或"内存缓冲区"。
4. **内存分配区域：** Redis使用内存分配区域来管理内存分配和释放。不同的区域用于不同的数据类型和大小，以优化内存的使用。例如，Redis会使用专用的内存区域来存储短字符串对象。
5. **共享对象池：** Redis中的一些常用数据（例如整数、空字符串）被存储在共享对象池中，以减少内存占用和提高性能。这些对象可以被多个键引用，从而节省内存。
6. **复制相关的内存区域：** 在Redis主从复制中，Redis需要额外的内存区域来存储主节点的复制缓冲区和从节点的复制状态等信息。
7. **AOF和RDB持久化文件的缓冲区：** 在AOF（Append-Only File）和RDB（Redis Database）持久化机制中，Redis使用内存缓冲区来存储待写入的持久化文件数据，然后批量写入到磁盘。

#### RedisObject 的结构

Redis 中的数据类型很多，不同的数据类型都有元数据需要记录（最后一次访问时间、被引用次数），redis 会用一个 RedisObject 结构体来统一记录这些元数据，同时指向实际数据。一个 RedisObject 包含了 8 个字节的元数据和一个 8 个字节的指针，这个指针再进一步指向具体数据类型的实际数据所在。内部组成如下：

- type: 表示值的类型
- encoding: 值的编码方式，用于表示 Redis 中实现各个基本类型的底层数据结构，例如 SDS、压缩列表、哈希、跳表
- lru: 记录了这个对象最后一次被访问的时间，用于淘汰过期的键值对
- refcount：记录对象的引用计数
- *prt：指向数据的指针

#### SDS 简单动态字符串

Sting 类型保存数据，除了记录实际数据，还需要额外的内存空间记录数据长度、空间实用等元数据，当实际保存的数据很小时，元数据的开销就显得很大了。

**SDS 不仅可以保存文本数据，还可以保存二进制数据**

**SDS结构**：当保存的数据中包含字符时，String 类型会采用 Simple Dynamic String SDS 结构体保存。

- **buf：**字节数组，保存实际数据。为了表示字节数组的结束，redis会自动在数组最后添加一个 "\0" ，这会占用 1 字节。
- **len：**占 4 字节，表示 buf 的已用长度。
- **alloc：**占 4 字节，表示 buf 的实际分配长度，一般大于 len。

其中，buf 保存实际数据，len 和 alloc 属于 SDS 结构体中的额外开销。

String 类型保存数据的编码方式：

- **int 编码方式：**当保存 64 位有符号的整数时，String 类型会把它保存为一个 8 字节的 Long 类型整数。具体就是将 RedisObject 中的指针直接赋值为整数数据，这样不需要额外的指针再指向整数，节省了指针的空间开销。
- **embstr 编码方式：**保存的是字符串数据，并且字符串小于等于 44 个字节，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片。
- **row 编码模式：**当字符串大于 44 字节时，Redis 就不再把 SDS 和 RedisObject 布局在一起了，而是会给 SDS 分配独立空间，再用指针指向 SDS 结构。

##### dictEntry

Redis 会使用一个全局哈希表保存所有的键值对，哈希表的每一项是一个 dictEntry 结构体。

dictEntry 结构体中有 3 个 8 个字节的指针，分别指向 key、value 以及下一个 dictEntry，三个指针共 24 字节。 

但 dictEntry 会占用 32 个字节，Redis 实用的内存分配库是 jemalloc 。

jemalloc 在分配内存时，会找最接近的 2 的幂次数作为分配的空间，如果申请 24 字节，会分配 32 字节。

**Redis 存储一个 Sting 类型数据需要的内存为：dictEntry (32字节) + RedisObject + SDS ，具体要看编码方式。**

#### 压缩列表 ziplist

压缩列表是一种非常节省内存的结构，表头有三个字段 zlbytes、zltail 和 zlen，分别表示长度、列表尾的偏移量，以及列表中的 entry 个数。压缩列表之所以能节省内存，在于它是用一系列连续的 entry 保存数据。

entry 的元数据结构：

- **prev_len：**表示前一个 entry 的长度。prev_len 的取值有两种情况，1 字节或 5 字节。1字节可以表示的数值范围为 0～255，但压缩列表中的 zlend 的取值默认为 255 表示压缩列表的结束。所以，当上一个 entry 的长度小于 254 字节时，prev_len 取值为 1 字节，否则取值为 5 字节。
- **len：**表示自身长度，4字节
- **encoding：**表示编码方式，1 字节
- **content：**保存实际数据

Redis 基于压缩列表实现了，List、Hash 和 Sorted Set 这样的集合类型，这样节省了 dictEntry 的开销。

#### Redis 实例中的阻塞点

1. 和客户端交互时的阻塞点
   - **集合的全量查询、删除和聚合操作**
   - **bigkey 的删除**
   - **清空数据库**
2. 和磁盘交互时的阻塞点
   - **AOF 日志同步写**
3. 主从节点交互时的阻塞点
   - **加载 RDB 文件**
4. 切片集群实例交互的阻塞点
   - **哈希槽数据迁移**（渐进式迁移，阻塞风险不大）
   - **bigkey 的迁移**

#### Redis 异步子线程机制

在 Redis 的阻塞点中，除了 **集合的全量查询和聚合操作** 和 **从库加载 RDB 文件**，剩下的 bigkey删除、清空数据库和 AOF 日志同步写，这三个操作可以使用 Redis 的异步自线程机制实现。

Redis 主线程启动后，会使用操作系统提供的 pthread_create 函数创建 3 个子线程，分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行。

主线程通过一个链表形式的任务队列和子线程进行交互。当收到键值对删除和清空数据库的操作时，主线程会把这个操作封装成一个任务，放入任务队列中，然后给客户端返回一个完成信息，表示删除已完成。等到后台自线程从任务队列中读取到任务后，才开始实际删除键值对并释放内存空间，这样不会阻塞主线程。

异步的键值对删除和数据库清空操作是 Redis 4.0 后提供的功能，新的命令如下：

- 键值对删除：当集合类型中有大量元素需要删除时，建议使用 UNLINK 命令
- 清空数据库：可以在 FLUSHDB 和 FLUSHALL 命令后加上 ASYNC，这样就可以让后台自线程异步清空数据

集合的全量查询和聚合操作、从库加载 RDB 文件，这两个动作是在关键路径上的，无法使用异步操作完成

- 集合全量查询和聚合操作：可以使用 scan 命令，分批读取数据，再在客户端进行聚合计算
- 从库加载 RDB 文件：把主库的数据量控制在 2～4GB，以保证 RDB 文件能以较快的速度加载

#### CPU 结构也会影响 Redis 性能

**NUMA 架构：**多 CPU 架构下，也称为非统一内存访问架构，应用程序可以在不同的处理器上运行，如果应用程序从一个 CPU Socket 上调度到另一个 CPU Socket 上，就可能会出现远端内存访问的情况，会增加应用程序的执行时间。

**远端内存访问：**如果一个应用程序先在一个 CPU Socket 上运行，并且把数据保存到内存，然后被调度到另一个 CPU Socket 上运行，此时在进行内存访问，就需要访问之前 Socket 上连接的内存。远端内存访问和访问 Socket 直接连接的内存比，会增加应用程序的延迟。

**多核 CPU 架构下：**Redis 如果在不同的核上运行，需要频繁的进行上下文切换，这会影响 Redis 的性能。建议把 Redis 实例和某个核绑定，这样就能重复利用核上的 L1、L2 缓存，降低响应延迟。

**网络性能优化：**将网络中断处理程序和 CPU 绑定在一起。如果服务器是 NUMA 架构，为了避免 Redis 跨 CPU Sokcet 访问网络数据，建议将 Redis 实例和网络中断程序绑在同一个 CPU Socket 下的不同核上，以提高 Redis 的运行性能。

**绑核带来的问题：**除主线程外，Redis 还有用于 RDB 生成和 AOF 重写的子进程，以及 4.0 版本后用于惰性删除的后台线程。当 Redis 和一个逻辑核绑定之后，这些子进程和后台线程会和主线程竞争 CPU 资源，也会对 Redis 性能造成影响。两个解决方案：

- 可以将 Redis 实例绑在物理核上，这样 Redis 的主线程、子进程和后台线程可以共享使用一个物理核上的两个逻辑核。
- 修改 Redis 源码，增加绑核操作，把子进程和后台线程绑到不同的核上，避免对主线程的 CPU 资源竞争。Redis 6.0 之后，已经支持 CPU 核绑定的配置操作。

#### Redis 性能变慢时的 Checklist 

1. 查看 Redis 实例在当前环境下的基线性能

2. 是否使用了慢命令，如果是的话，用其他命令替代慢命令，或者把聚合计算命令放在客户端做

3. 是否对过期 key 设置了相同的过期时间，对于批量删除的 key ，可以在每个 key 的过期时间上加上一个随机数，避免同时删除

4. 是否存在 bigkey，对于 bigkey 的删除操作，redis 4.0及以上的版本，可以直接利用异步线程机制减少主线程阻塞。如果是 4.0 之前的版本，使用 SCAN 命令迭代删除；对于 bigkey 的集合查询和聚合操作，可以使用 SCAN 命令在客户端完成。

5. Redis 的 AOF 配置级别是什么，业务层面是否的确需要这一可靠性级别。如果需要高性能，同时也允许丢失数据，可以将配置项 no-appendfsync-on-rewrite 设置为 yes，避免 AOF 重写和 fsync 竞争磁盘 I/O 资源，导致 Redis 延迟增加。

6. Redis 实例的内存是否过大，操作系统内存是否发生了 swap，如果发生了说明内存不足，需要增加机器内存，或使用 Redis 集群分摊单机 Redis 的键值对数量和内存压力。避免 Redis 和其他内存需求大的应用共享机器的情况。

   > 内存 swap 是操作系统将内存数据在内存和磁盘间来回换入和换出的机制，涉及到磁盘的读写，所以一旦发生 swap 无论是换入的数据的进程还是换出的数据的进程，性能都会收到慢速磁盘读写的影响。

7. Redis 实例的运行环境中是否开启了透明大页机制，如果是的话，关闭内存大页机制。

   > 内存大页可以给 Redis 带来内存分配方面的收益，但 Redis 的持久化会采用写时复制机制，一旦有数据要修改 Redis 不会直接修改内存中的数据，而是将这些数据拷贝一份，然后进行修改，内存大页机制会导致大量的拷贝，影响 Redis 的性能。

8. 是否运行了 Redis 主从集群，如果是的话，把主库实例的数据量控制在 2～4 GB，以免主从复制时，从库因加载大的 RDB 文件而阻塞。

9. 是否使用了多核 CPU 或 NUMA 架构的机器运行 Redis 实例，使用多核 CPU 时，可以给 Redis 绑定物理核；使用 NUMA 架构时，注意将 Redis 实例和网络中断处理程序运行在同一个 CPU Socket上。		

#### Redis 中的内存碎片

- **内因：内存分配器的分配策略**

  Redis 默认使用 jemalloc 内存分配器，jemalloc 分配内存大小时使用 2 的次幂计算，当申请的内存最接近某个值时，分配给它相应大小的空间。例如申请20字节，jemalloc 会分配32字节。这样做是为了减少分配次数。

- **外因：键值对大小不一和删改操作**

  - 不同业务系统数据大小不同，向Redis 申请内存空间分配时，会有大小不一的空间需求。
  - 键值的修改和删除，会导致空间的扩容和释放

##### 内存碎片率 mem_fragmentation_ratio 

Redis 提供了 INFO 命令，可以用来查询内存使用的详细信息。

INFO 命令输出的内容中，mem_fragmentation_ratio 指标用来表示当前 Redis 的内存碎片率。

```
mem_fragmentation_ratio = used_memory_rss/ used_memory	# 计算公式
```

used_memory_rss：表示操作系统实际分配给 Redis 的物理内存空间，其中就包含了碎片

used_memory：表示 Redis 为了保存数据实际申请使用的空间

- **mem_fragmentation_ratio 大于 1 但小于 1.5**     这种情况是合理的，有些内存碎片是合理的、难以避免的。
- **mem_fragmentation_ratio 大于 1.5**    此时内存碎片率超过了 50%，需要采取措施降低。 

##### 如何清理内存碎片

- 重启Redis可以实现，但不可取。重启会导致服务中断，且如果没有持久化数据，数据就会丢失。即使持久化了数据，还需要通过 RDB 或 AOF 进行恢复，恢复的时常取决于文件大小，恢复阶段无法提供服务。

- Redis 4.0-RC3 版本后提供了内存碎片自动清理。具体来说就是通过数据拷贝的方式，把原本不连续的空间变成连续空间。

  清理碎片是有代价的，redis 是单线程，数据拷贝存在时间开销，在数据拷贝时无法及时处理请求，性能会降低。而且，数据拷贝对顺序性又要求，会进一步增加 Redis 的等待时间。Redis 的自动清理机制提供了一些参数，可以根据实际应用中的数据量和性能要求进行调整。

#### Redis 中的缓冲区

##### **客户端输入缓冲区和输出缓冲区**

服务器端给每个连接的客户端都设置了一个输入缓冲区和输出缓冲区。

输入缓冲区会把客户端发送过来的命令暂存起来，Redis 主线程再从输入缓冲区中读取命令进行处理。当 Redis 主线程处理完数据后，会把结果写入到输出缓冲区，再通过输出缓冲区返回给客户端。

##### **主从复制缓冲区**

- replication buffer 全量复制时的缓冲区，主节点在向从节点传输 RDB 文件的同时，会继续接收客户端发送的写命令请求。这些写命令会先保存到 replation buffer 中，等 RDB 文件传输结束后，再发送给从节点去执行。
- repl_backlog_buffer 增量复制时的缓冲区，是一个环形缓冲区，缓冲区被写满后，会覆盖缓冲区中的旧命令。如果从节点还没有同步这些旧命令，会造成主从节点之间重新开始执行全量复制。

##### 缓冲区溢出的原因和解决方案

- 命令数据发送过快过大

  解决方法：对于客户端缓冲区来说避免 bigkey；对于复制缓冲区来说，避免过大的 RDB 文件

- 命令数据处理较慢

  解决方法：减少 Redis 主线程上的阻塞操作，使用异步的删除操作、异步的 AOF 日志写入

- 缓冲区过小

  解决方法：配置合理的缓冲区大小。当然输入缓冲区的大小不支持配置，除非修改 Redis 源码

#### Redis 的内存淘汰策略

Redis 4.0 之后，提供了 8 中数据淘汰策略

- **noevction** 策略，不进行数据淘汰，一旦缓存被写满直接返回错误
- 在设置了过期时间的数据中进行淘汰
  - **volatile-ttl：**在筛选时，针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的约先被删除
  - **volatile-random：**在设置了过期时间的键值对中，进行随机删除
  - **volatile-lru：**使用 LRU 算法筛选设置了过期时间的键值对
  - **volatile-lfu：**使用 LFU 算法筛选设置了过期时间的键值对
- 在所有的数据中进行淘汰
  - **allkeys-random：**从所有键值对中随机选择并删除数据
  - **allkeys-lru：**使用 LRU 算法在所有数据中筛选
  - **allkeys-lfu：**使用 LFU 算法在所有数据中筛选

使用建议：

- **优先使用 allkeys-lru**，充分利用 LRU 算法优势，把最经常访问的数据留在缓存中，提升应用的访问性能。如果业务数据有明显的冷热分区，推荐 allkeys-lru
- 如果业务数据的访问频率相差不大，没有明显的冷热分区，建议使用 allkeys-random，随机淘汰
- **如果业务数据中有置顶的需求**，可以使用 volatile-lru，同时不给置顶数据设置过期时间，这样置顶数据不会被淘汰，其他数据会在过期时根据 LRU 规则进行筛选。

#### Redis 中的 LRU 算法

##### LRU 算法

按照最近最少使用原则，使用链表来组织数据，新增数据或链表中的数据被访问，都会将数据放到链表的头部，淘汰数据时淘汰链表尾部的数据。

##### Redis 中的 LRU 实现

LRU 算法需要通过链表来管理所有的缓存数据，这会带来额外的空间开销。当有数据被访问，需要将他移动到链表的头部，如果有大量的数据被访问，将会带来大量的链表移动操作，会很耗时，影响 Redis 的性能。

为了避免数据淘汰影响缓存的性能，Redis 中对 LRU做了简化：RedisObject 的 lru 字段上记录了每个数据的最近一次访问时间戳，当 Redis 决定淘汰数据时，第一次随机选出 N 个数据，作为候选集合，比较这些数据的 lru 字段，把字段值最小的数据淘汰。

当需要再次淘汰数据时，Redis 需要挑选数据进入第一次淘汰时的候选集合。挑选数据的标准：新进入候选集合的数据的 lru 字段值必须小于候选集合中最小的 lru 值。Redis 提供了一个配置参数，maxmemory-samples 作为候选集合的大小，当新数据进入候选集合，候选集合的数据量达到 maxmemory-samples 时，Redis 会将候选集合中 lru 字段值最小的数据淘汰。这样 Redis 就不用为所有数据维护一个大链表了，也不用每次数据访问时都移动链表项，提升了缓存的性能。

#### 如何保证缓存和后端数据库的一致性

##### Cache Aside 策略

只读缓存模式，读操作命中缓存返回，未命中则查询数据库，再写入缓存后返回。写操作直接更新数据库，并删除缓存。

- 优点：一切以后端数据库为准，可以保证缓存和数据库的一致性。
- 缺点：写操作会使缓存失效，再次读取需要从数据库中加载。

##### Read/Write Through 策略

应用层读写都只操作缓存，不需要关心后端数据库。应用层在操作缓存时，缓存层会自动从数据库中加载或写回数据库。

- 优点：应用层只需要操作缓存
- 缺点：需要缓存层和后端数据库联动

##### Write Back 策略

读写缓存 + 异步写回策略，写操作只写缓存，读操作如果命中缓存则直接返回，否则需要从数据库把数据加载到缓存中。加载前如果缓存已满，则先把需要淘汰的缓存数据写回到后端数据库中，再把读取的数据放入缓存。

- 优点：写操作只写缓存，速度快
- 缺点：如果缓存宕机，系统会发生异常，导致缓存和数据库不一致，可能会丢数据。

这种策略经常使用在操作系统 Page Cache 中，或应对大量写操作的数据库引擎中。





